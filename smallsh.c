/*
Author: George Kochera
Date Creatd: 1/25/2021
Filename: smallsh.c
Description: Contains the core functions to display the smallsh shell and handle text input
*/

#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "smallsh_commands.h"
#include "smallsh_sighandler.h"
#include "smallsh_structs.h"
#include "smallsh_childpids.h"

/*
Gets user input up to the enter key, discards the newline character at the end
*/
static char * getUserInput()
{
    // We create an array to store the user input as a string
    char * input = (char*)calloc(301, sizeof(char));

    // Get the string
    fgets(input, 300, stdin);

    // Remove the newline at the end
    for (int i = 0; i < 301; i++)
    {
        if (input[i] == '\n')
        {
            input[i] = '\0';
        }
    }

    // Return a pointer to the string
    return input;
}


/*
Checks for the $$ expansion in user input, this function will return the newToken
with the current pid of the parent process in place of $$ or it will simply return the old
token unchanged.
*/
static char * checkForPidExpansion (char* token)
{
    char * expansionPosition;
    char * thisToken = (char *)calloc(strlen(token), sizeof(char));
    strcpy(thisToken, token);

    // Check to see if the $$ expansion appears at least once in the token
    if (((expansionPosition = strstr(thisToken, "$$")) != NULL))
    {

        // if it does, we get the pid for smallsh, create a string with it and
        // start the process of replacing it as many times as it occurs
        int smallshPid = getpid();
        char * smallshPidAsString = (char*)calloc(8, sizeof(char));
        sprintf(smallshPidAsString, "%d", smallshPid);

        // this will hold the new token we return
        char * newToken = (char*)calloc(strlen(token) + strlen(smallshPidAsString), sizeof(char));
        
        // We check to see if strstr() returned a position for $$ if it did, we replace it
        while (expansionPosition != NULL)
        {
            // cat the stuff before $$
            strncat(newToken, thisToken, (int)(expansionPosition - thisToken));

            // replace $$ with the pid of smallsh
            strncat(newToken, smallshPidAsString, strlen(smallshPidAsString));

            // cat everything after $$
            strcat(newToken, thisToken + (int)(expansionPosition - thisToken) + strlen("$$"));

            // see if there are any more occurences of $$ and if there are we repeat as necessary
            if ((expansionPosition = strstr(newToken, "$$")) != NULL)
            {
                // We copy over what we have expanded already
                thisToken = (char*)realloc(newToken, strlen(newToken));

                // and create space for the next expansion
                newToken = (char*)calloc(strlen(thisToken) + strlen(smallshPidAsString), sizeof(char));
            }
        }

        // free our dynamic memory and return the result
        free(thisToken);
        return newToken;
    } 

    // if strstr() didn't find $$ we just return the token as is
    else
    {
        return NULL;
    }
}


/*
Tokenizes the user input with whitespace as the delimeter
*/
char ** tokenizeUserInput(char* userInputAsLine)
{
    // SOURCE: https://stackoverflow.com/questions/9860671/double-pointer-char-operations
    // We setup some variables to hold relevant information for processing an input string. 

    // Holds the current index of the dynamic array that holds user input tokens
    int userInputTokensIndex = 0;

    // Holds the current size of the dyanamic array for user tokens
    int userInputTokensQuantity = 4;

    // Holds the pointer that points to the dynamic array of user input tokens
    char ** userInputTokens = (char **)calloc(userInputTokensQuantity, sizeof(char*));

    // Used for strtok_r for reentrancy
    char * remainderOfString = NULL;

    // Holds the pointer to the token that was checked for PID expansion
    char * checkedToken = NULL;

    // Flag to tell us if we used dyanamic memory, so we know to clear it
    bool dMemUsed = false;

    // holds the token generated by strtok_r
    char * token = strtok_r(userInputAsLine, " ", &remainderOfString);

    // Handle the case where the user entered something
    while (token != NULL)
    {
        // Check the token, handle expansion of $$, set the dMemUsed flag to true if we had to expand
        // it because it uses dynamic memory.
        if ((checkedToken = checkForPidExpansion(token)) != NULL)
        {
            token = checkedToken;
            dMemUsed = true;
        }

        // Create a new pointer of length token + 1, and copy the token to it
        char * savedToken = (char *)calloc(strlen(token) + 1, sizeof(char));
        strcpy(savedToken, token);

        // Save the token to the array of tokens, and verify we dont need to expand the array
        // If we do, expand the array by double so we don't overflow.
        userInputTokens[userInputTokensIndex++] = savedToken;
        if (userInputTokensIndex == userInputTokensQuantity)
        {
            userInputTokensQuantity *= 2;
            userInputTokens = (char **)realloc(userInputTokens, userInputTokensQuantity * sizeof(char *));
        }

        // We are done with the token, so it can be freed if it used dynamic memory.
        if (dMemUsed)
        {
            free(token);
            dMemUsed = false;
        }

        // Get our next token
        token = strtok_r(NULL, " ", &remainderOfString);

    }
    
    // Handle the special case where the user just pushes the return key
    if (userInputTokensIndex == 0)
    {
        free(userInputTokens);
        return NULL;
    }
    return userInputTokens;
}


/*
Handle the user input. All user input requires the userinput as tokens, the pointer for the status message incase we need to change it,
the smallshFileInfo struct so that we can perform redirection as necessary and the childPids struct pointer so that we can add pids to it
in the event we spawn off a background child process
*/
static void handleUserInput(char ** userInputAsTokens, char* status, struct smallshFileInfo* smallshFileInfo, struct childPids* childPids)
{
    // Handle blank lines entered by user/script
    if (userInputAsTokens != NULL)
    {
        // Handle comments entered by user/script
        if (userInputAsTokens[0][0] != '#')
        {
            // Handle valid lines entered by user
            char * command = userInputAsTokens[0];

            // If the command is exit, execute the exit function
            if (!(strcmp(command, "exit")))
            {
                cmd_exit(childPids);
            }

            // Entrance point to the status function
            else if (!(strcmp(command, "status")))
            {
                cmd_status(status);
                
            }

            // Entrance point to the change directory function
            else if (!(strcmp(command, "cd")))
            {
                cmd_cd(userInputAsTokens);
            }

            // Entrance point to all other functions.
            else
            {
                cmd_other(userInputAsTokens, status, smallshFileInfo, childPids);
            }
        }

    }

}


/*
Main prompt loop
This is the main entrance point for the smallsh program and executes until the exit command is given, under
normal conditions, this will not return.
*/
void smallsh()
{
    // Setup some necessary variables for holding user input and status
    char * status = (char*)calloc(512, sizeof(char));
    char * input = NULL;
    char ** inputTokens = NULL;

    // Take care of keeping track of child pids using this struct
    struct childPids* childPids = initializeChildPids();

    // Capture the signals, we will not exit on SIGINT, and we will NOT IGNORE SIGTSTP, but
    // instead want to handle it our own way.
    attachSIGINT(NOEXIT);
    attachSIGTSTP(NOIGNORE);


    while (true)
    {
        // Check child PIDs status
        pollChildPids(childPids);

        // Print the shell prompt, gather user input
        printf(": ");
        fflush(stdout);
        input = getUserInput();
        
        // Check for redirection
        struct smallshFileInfo* smallshFileInfo = findInputRedirectionInInput(input);

        // Tokenize the user input
        inputTokens = tokenizeUserInput(input);

        // now handle the tokens and redirection
        handleUserInput(inputTokens, status, smallshFileInfo, childPids);

        // Free the dynamic memory used, and go back to the top. 
        free(input);
        free(inputTokens);
    }
}

